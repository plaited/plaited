export const snapshot = {};

snapshot[`Island.template() 1`] = `
"<()=>{
        /** If the tag is script we must explicitly pass trusted */ if (tag === 'script' && !trusted) {
            throw new Error('Script tag not allowed unless \\\\'trusted\\\\' property set');
        }
        /** Now to determine what our root element is */ const root = typeof tag === 'string' ? tag.toLowerCase() : tag();
        const rootAttrs = [];
        /** if we have dataTrigger attribute wire up formatted correctly*/ dataTrigger && rootAttrs.push(\`\${_dataTrigger}=\\"\${Object.entries(dataTrigger).map(([ev, req])=>\`\${ev}->\${req}\`).join(' ')}\\"\`);
        /** if we have className add it to Element */ className && rootAttrs.push(\`class=\\"\${className}\\"\`);
        /** if we have htmlFor add it to Element */ htmlFor && rootAttrs.push(\`for=\\"\${htmlFor}\\"\`);
        /** if we have style add it to element */ style && rootAttrs.push(\`style=\\"\${Object.entries(style).map(([prop, val])=>\`\${prop}:\${val};\`).join(' ')}\\"\`);
        /** next we want to loops through our attributes */ for(const key in attributes){
            /** all events our delegated via the data-trigger attribute so we want
       * throw on attempts to provide \`on\` attributes
       */ if (key.startsWith('on')) {
                throw new Error('Attributes starting with \\\\'on\\\\' are not allowed.');
            }
            if (!primitives.has(trueTypeOf(attributes[key]))) {
                throw new Error(\`Attributes not declared in BaseProps must be of type Primitive: \${key} is not primitive\`);
            }
            /** grab the value from the attribute */ const value = attributes[key];
            /** convert camelCase attributes into dash-case ones */ const dashKey = key.replace(/[A-Z]/g, (m)=>\`-\${m.toLowerCase()}\`);
            /** test for and handle boolean attributes */ if (booleanAttrs.has(dashKey)) {
                rootAttrs.push(\`\${dashKey}\`);
                continue;
            }
            /** set the value so long as it's not nullish in we use the formatted value  */ const formattedValue = value ?? '';
            /** handle the rest of the attributes */ rootAttrs.push(\`\${dashKey}=\\"\${trusted ? \`\${formattedValue}\` : escape(\`\${formattedValue}\`)}\\"\`);
        }
        /** Our tag is a void tag so we can return it once we apply attributes */ if (typeof root === 'string' && voidTags.has(root)) {
            return \`<\${[
                root,
                ...rootAttrs
            ].join(' ')}/>\`;
        }
        /** Test if the the tag is a string and if it's a custom element */ const isCustomElement = customElementRegex.test(root);
        /** If our template is for a custom element we're going to create a
     * declarative shadow dom
     */ const templateAttrs = [];
        const templateChildren = [];
        if (isCustomElement) {
            /** Set the mode of the shadowDom */ templateAttrs.push(\`shadowrootmode=\\"\${shadowRootMode}\\"\`);
            /** We destructured out the styles attribute as it's only for
       * custom elements declarative shadow dom  we create the style node
       * append the styles as the first child of the declarative shadowDom template */ if (styles) {
                templateChildren.push(serverTemplate('style', undefined, typeof styles === 'string' ? [
                    styles
                ] : [
                    ...styles
                ]));
            }
            /** We generally want to delegate focus to the first focusable element in
       * custom elements
       */ templateAttrs.push(\`shadowrootdelegatesfocus=\\"\${shadowRootDelegatesFocus}\\"\`);
        /** now that we've configured our declarative shadowDom
       * we append it to our root element.
       */ }
        const rootChildren = [];
        /** time to append the children to our template if we have em*/ const length = children.length;
        for(let i = 0; i < length; i++){
            const child = children[i];
            /** P1 Child is and string and custom element */ if (isCustomElement && typeof child === 'string') {
                templateChildren.push(trusted ? child : escape(child));
                continue;
            }
            /** P2 string not custom element */ if (typeof child === 'string') {
                rootChildren.push(trusted ? child : escape(child));
                continue;
            }
            /** P3 ServerElement and and the child is slotted */ if (isCustomElement && child.slot) {
                rootChildren.push(child());
                continue;
            }
            /** P4 ServerElement and custom element */ if (isCustomElement) {
                templateChildren.push(child());
                continue;
            }
            /**  P5 default use root tag*/ rootChildren.push(child());
        }
        const template = serverTemplate('template', templateAttrs, templateChildren);
        return serverTemplate(root, rootAttrs, [
            template,
            ...rootChildren
        ]);
    }><template></template></()=>{
        /** If the tag is script we must explicitly pass trusted */ if (tag === 'script' && !trusted) {
            throw new Error('Script tag not allowed unless \\\\'trusted\\\\' property set');
        }
        /** Now to determine what our root element is */ const root = typeof tag === 'string' ? tag.toLowerCase() : tag();
        const rootAttrs = [];
        /** if we have dataTrigger attribute wire up formatted correctly*/ dataTrigger && rootAttrs.push(\`\${_dataTrigger}=\\"\${Object.entries(dataTrigger).map(([ev, req])=>\`\${ev}->\${req}\`).join(' ')}\\"\`);
        /** if we have className add it to Element */ className && rootAttrs.push(\`class=\\"\${className}\\"\`);
        /** if we have htmlFor add it to Element */ htmlFor && rootAttrs.push(\`for=\\"\${htmlFor}\\"\`);
        /** if we have style add it to element */ style && rootAttrs.push(\`style=\\"\${Object.entries(style).map(([prop, val])=>\`\${prop}:\${val};\`).join(' ')}\\"\`);
        /** next we want to loops through our attributes */ for(const key in attributes){
            /** all events our delegated via the data-trigger attribute so we want
       * throw on attempts to provide \`on\` attributes
       */ if (key.startsWith('on')) {
                throw new Error('Attributes starting with \\\\'on\\\\' are not allowed.');
            }
            if (!primitives.has(trueTypeOf(attributes[key]))) {
                throw new Error(\`Attributes not declared in BaseProps must be of type Primitive: \${key} is not primitive\`);
            }
            /** grab the value from the attribute */ const value = attributes[key];
            /** convert camelCase attributes into dash-case ones */ const dashKey = key.replace(/[A-Z]/g, (m)=>\`-\${m.toLowerCase()}\`);
            /** test for and handle boolean attributes */ if (booleanAttrs.has(dashKey)) {
                rootAttrs.push(\`\${dashKey}\`);
                continue;
            }
            /** set the value so long as it's not nullish in we use the formatted value  */ const formattedValue = value ?? '';
            /** handle the rest of the attributes */ rootAttrs.push(\`\${dashKey}=\\"\${trusted ? \`\${formattedValue}\` : escape(\`\${formattedValue}\`)}\\"\`);
        }
        /** Our tag is a void tag so we can return it once we apply attributes */ if (typeof root === 'string' && voidTags.has(root)) {
            return \`<\${[
                root,
                ...rootAttrs
            ].join(' ')}/>\`;
        }
        /** Test if the the tag is a string and if it's a custom element */ const isCustomElement = customElementRegex.test(root);
        /** If our template is for a custom element we're going to create a
     * declarative shadow dom
     */ const templateAttrs = [];
        const templateChildren = [];
        if (isCustomElement) {
            /** Set the mode of the shadowDom */ templateAttrs.push(\`shadowrootmode=\\"\${shadowRootMode}\\"\`);
            /** We destructured out the styles attribute as it's only for
       * custom elements declarative shadow dom  we create the style node
       * append the styles as the first child of the declarative shadowDom template */ if (styles) {
                templateChildren.push(serverTemplate('style', undefined, typeof styles === 'string' ? [
                    styles
                ] : [
                    ...styles
                ]));
            }
            /** We generally want to delegate focus to the first focusable element in
       * custom elements
       */ templateAttrs.push(\`shadowrootdelegatesfocus=\\"\${shadowRootDelegatesFocus}\\"\`);
        /** now that we've configured our declarative shadowDom
       * we append it to our root element.
       */ }
        const rootChildren = [];
        /** time to append the children to our template if we have em*/ const length = children.length;
        for(let i = 0; i < length; i++){
            const child = children[i];
            /** P1 Child is and string and custom element */ if (isCustomElement && typeof child === 'string') {
                templateChildren.push(trusted ? child : escape(child));
                continue;
            }
            /** P2 string not custom element */ if (typeof child === 'string') {
                rootChildren.push(trusted ? child : escape(child));
                continue;
            }
            /** P3 ServerElement and and the child is slotted */ if (isCustomElement && child.slot) {
                rootChildren.push(child());
                continue;
            }
            /** P4 ServerElement and custom element */ if (isCustomElement) {
                templateChildren.push(child());
                continue;
            }
            /**  P5 default use root tag*/ rootChildren.push(child());
        }
        const template = serverTemplate('template', templateAttrs, templateChildren);
        return serverTemplate(root, rootAttrs, [
            template,
            ...rootChildren
        ]);
    }>"
`;

snapshot[`Island.template() 2`] = `
"<()=>{
        /** If the tag is script we must explicitly pass trusted */ if (tag === 'script' && !trusted) {
            throw new Error('Script tag not allowed unless \\\\'trusted\\\\' property set');
        }
        /** Now to determine what our root element is */ const root = typeof tag === 'string' ? tag.toLowerCase() : tag();
        const rootAttrs = [];
        /** if we have dataTrigger attribute wire up formatted correctly*/ dataTrigger && rootAttrs.push(\`\${_dataTrigger}=\\"\${Object.entries(dataTrigger).map(([ev, req])=>\`\${ev}->\${req}\`).join(' ')}\\"\`);
        /** if we have className add it to Element */ className && rootAttrs.push(\`class=\\"\${className}\\"\`);
        /** if we have htmlFor add it to Element */ htmlFor && rootAttrs.push(\`for=\\"\${htmlFor}\\"\`);
        /** if we have style add it to element */ style && rootAttrs.push(\`style=\\"\${Object.entries(style).map(([prop, val])=>\`\${prop}:\${val};\`).join(' ')}\\"\`);
        /** next we want to loops through our attributes */ for(const key in attributes){
            /** all events our delegated via the data-trigger attribute so we want
       * throw on attempts to provide \`on\` attributes
       */ if (key.startsWith('on')) {
                throw new Error('Attributes starting with \\\\'on\\\\' are not allowed.');
            }
            if (!primitives.has(trueTypeOf(attributes[key]))) {
                throw new Error(\`Attributes not declared in BaseProps must be of type Primitive: \${key} is not primitive\`);
            }
            /** grab the value from the attribute */ const value = attributes[key];
            /** convert camelCase attributes into dash-case ones */ const dashKey = key.replace(/[A-Z]/g, (m)=>\`-\${m.toLowerCase()}\`);
            /** test for and handle boolean attributes */ if (booleanAttrs.has(dashKey)) {
                rootAttrs.push(\`\${dashKey}\`);
                continue;
            }
            /** set the value so long as it's not nullish in we use the formatted value  */ const formattedValue = value ?? '';
            /** handle the rest of the attributes */ rootAttrs.push(\`\${dashKey}=\\"\${trusted ? \`\${formattedValue}\` : escape(\`\${formattedValue}\`)}\\"\`);
        }
        /** Our tag is a void tag so we can return it once we apply attributes */ if (typeof root === 'string' && voidTags.has(root)) {
            return \`<\${[
                root,
                ...rootAttrs
            ].join(' ')}/>\`;
        }
        /** Test if the the tag is a string and if it's a custom element */ const isCustomElement = customElementRegex.test(root);
        /** If our template is for a custom element we're going to create a
     * declarative shadow dom
     */ const templateAttrs = [];
        const templateChildren = [];
        if (isCustomElement) {
            /** Set the mode of the shadowDom */ templateAttrs.push(\`shadowrootmode=\\"\${shadowRootMode}\\"\`);
            /** We destructured out the styles attribute as it's only for
       * custom elements declarative shadow dom  we create the style node
       * append the styles as the first child of the declarative shadowDom template */ if (styles) {
                templateChildren.push(serverTemplate('style', undefined, typeof styles === 'string' ? [
                    styles
                ] : [
                    ...styles
                ]));
            }
            /** We generally want to delegate focus to the first focusable element in
       * custom elements
       */ templateAttrs.push(\`shadowrootdelegatesfocus=\\"\${shadowRootDelegatesFocus}\\"\`);
        /** now that we've configured our declarative shadowDom
       * we append it to our root element.
       */ }
        const rootChildren = [];
        /** time to append the children to our template if we have em*/ const length = children.length;
        for(let i = 0; i < length; i++){
            const child = children[i];
            /** P1 Child is and string and custom element */ if (isCustomElement && typeof child === 'string') {
                templateChildren.push(trusted ? child : escape(child));
                continue;
            }
            /** P2 string not custom element */ if (typeof child === 'string') {
                rootChildren.push(trusted ? child : escape(child));
                continue;
            }
            /** P3 ServerElement and and the child is slotted */ if (isCustomElement && child.slot) {
                rootChildren.push(child());
                continue;
            }
            /** P4 ServerElement and custom element */ if (isCustomElement) {
                templateChildren.push(child());
                continue;
            }
            /**  P5 default use root tag*/ rootChildren.push(child());
        }
        const template = serverTemplate('template', templateAttrs, templateChildren);
        return serverTemplate(root, rootAttrs, [
            template,
            ...rootChildren
        ]);
    }><template></template></()=>{
        /** If the tag is script we must explicitly pass trusted */ if (tag === 'script' && !trusted) {
            throw new Error('Script tag not allowed unless \\\\'trusted\\\\' property set');
        }
        /** Now to determine what our root element is */ const root = typeof tag === 'string' ? tag.toLowerCase() : tag();
        const rootAttrs = [];
        /** if we have dataTrigger attribute wire up formatted correctly*/ dataTrigger && rootAttrs.push(\`\${_dataTrigger}=\\"\${Object.entries(dataTrigger).map(([ev, req])=>\`\${ev}->\${req}\`).join(' ')}\\"\`);
        /** if we have className add it to Element */ className && rootAttrs.push(\`class=\\"\${className}\\"\`);
        /** if we have htmlFor add it to Element */ htmlFor && rootAttrs.push(\`for=\\"\${htmlFor}\\"\`);
        /** if we have style add it to element */ style && rootAttrs.push(\`style=\\"\${Object.entries(style).map(([prop, val])=>\`\${prop}:\${val};\`).join(' ')}\\"\`);
        /** next we want to loops through our attributes */ for(const key in attributes){
            /** all events our delegated via the data-trigger attribute so we want
       * throw on attempts to provide \`on\` attributes
       */ if (key.startsWith('on')) {
                throw new Error('Attributes starting with \\\\'on\\\\' are not allowed.');
            }
            if (!primitives.has(trueTypeOf(attributes[key]))) {
                throw new Error(\`Attributes not declared in BaseProps must be of type Primitive: \${key} is not primitive\`);
            }
            /** grab the value from the attribute */ const value = attributes[key];
            /** convert camelCase attributes into dash-case ones */ const dashKey = key.replace(/[A-Z]/g, (m)=>\`-\${m.toLowerCase()}\`);
            /** test for and handle boolean attributes */ if (booleanAttrs.has(dashKey)) {
                rootAttrs.push(\`\${dashKey}\`);
                continue;
            }
            /** set the value so long as it's not nullish in we use the formatted value  */ const formattedValue = value ?? '';
            /** handle the rest of the attributes */ rootAttrs.push(\`\${dashKey}=\\"\${trusted ? \`\${formattedValue}\` : escape(\`\${formattedValue}\`)}\\"\`);
        }
        /** Our tag is a void tag so we can return it once we apply attributes */ if (typeof root === 'string' && voidTags.has(root)) {
            return \`<\${[
                root,
                ...rootAttrs
            ].join(' ')}/>\`;
        }
        /** Test if the the tag is a string and if it's a custom element */ const isCustomElement = customElementRegex.test(root);
        /** If our template is for a custom element we're going to create a
     * declarative shadow dom
     */ const templateAttrs = [];
        const templateChildren = [];
        if (isCustomElement) {
            /** Set the mode of the shadowDom */ templateAttrs.push(\`shadowrootmode=\\"\${shadowRootMode}\\"\`);
            /** We destructured out the styles attribute as it's only for
       * custom elements declarative shadow dom  we create the style node
       * append the styles as the first child of the declarative shadowDom template */ if (styles) {
                templateChildren.push(serverTemplate('style', undefined, typeof styles === 'string' ? [
                    styles
                ] : [
                    ...styles
                ]));
            }
            /** We generally want to delegate focus to the first focusable element in
       * custom elements
       */ templateAttrs.push(\`shadowrootdelegatesfocus=\\"\${shadowRootDelegatesFocus}\\"\`);
        /** now that we've configured our declarative shadowDom
       * we append it to our root element.
       */ }
        const rootChildren = [];
        /** time to append the children to our template if we have em*/ const length = children.length;
        for(let i = 0; i < length; i++){
            const child = children[i];
            /** P1 Child is and string and custom element */ if (isCustomElement && typeof child === 'string') {
                templateChildren.push(trusted ? child : escape(child));
                continue;
            }
            /** P2 string not custom element */ if (typeof child === 'string') {
                rootChildren.push(trusted ? child : escape(child));
                continue;
            }
            /** P3 ServerElement and and the child is slotted */ if (isCustomElement && child.slot) {
                rootChildren.push(child());
                continue;
            }
            /** P4 ServerElement and custom element */ if (isCustomElement) {
                templateChildren.push(child());
                continue;
            }
            /**  P5 default use root tag*/ rootChildren.push(child());
        }
        const template = serverTemplate('template', templateAttrs, templateChildren);
        return serverTemplate(root, rootAttrs, [
            template,
            ...rootChildren
        ]);
    }>"
`;

snapshot[`Island.template() 3`] = `
"<()=>{
        /** If the tag is script we must explicitly pass trusted */ if (tag === 'script' && !trusted) {
            throw new Error('Script tag not allowed unless \\\\'trusted\\\\' property set');
        }
        /** Now to determine what our root element is */ const root = typeof tag === 'string' ? tag.toLowerCase() : tag();
        const rootAttrs = [];
        /** if we have dataTrigger attribute wire up formatted correctly*/ dataTrigger && rootAttrs.push(\`\${_dataTrigger}=\\"\${Object.entries(dataTrigger).map(([ev, req])=>\`\${ev}->\${req}\`).join(' ')}\\"\`);
        /** if we have className add it to Element */ className && rootAttrs.push(\`class=\\"\${className}\\"\`);
        /** if we have htmlFor add it to Element */ htmlFor && rootAttrs.push(\`for=\\"\${htmlFor}\\"\`);
        /** if we have style add it to element */ style && rootAttrs.push(\`style=\\"\${Object.entries(style).map(([prop, val])=>\`\${prop}:\${val};\`).join(' ')}\\"\`);
        /** next we want to loops through our attributes */ for(const key in attributes){
            /** all events our delegated via the data-trigger attribute so we want
       * throw on attempts to provide \`on\` attributes
       */ if (key.startsWith('on')) {
                throw new Error('Attributes starting with \\\\'on\\\\' are not allowed.');
            }
            if (!primitives.has(trueTypeOf(attributes[key]))) {
                throw new Error(\`Attributes not declared in BaseProps must be of type Primitive: \${key} is not primitive\`);
            }
            /** grab the value from the attribute */ const value = attributes[key];
            /** convert camelCase attributes into dash-case ones */ const dashKey = key.replace(/[A-Z]/g, (m)=>\`-\${m.toLowerCase()}\`);
            /** test for and handle boolean attributes */ if (booleanAttrs.has(dashKey)) {
                rootAttrs.push(\`\${dashKey}\`);
                continue;
            }
            /** set the value so long as it's not nullish in we use the formatted value  */ const formattedValue = value ?? '';
            /** handle the rest of the attributes */ rootAttrs.push(\`\${dashKey}=\\"\${trusted ? \`\${formattedValue}\` : escape(\`\${formattedValue}\`)}\\"\`);
        }
        /** Our tag is a void tag so we can return it once we apply attributes */ if (typeof root === 'string' && voidTags.has(root)) {
            return \`<\${[
                root,
                ...rootAttrs
            ].join(' ')}/>\`;
        }
        /** Test if the the tag is a string and if it's a custom element */ const isCustomElement = customElementRegex.test(root);
        /** If our template is for a custom element we're going to create a
     * declarative shadow dom
     */ const templateAttrs = [];
        const templateChildren = [];
        if (isCustomElement) {
            /** Set the mode of the shadowDom */ templateAttrs.push(\`shadowrootmode=\\"\${shadowRootMode}\\"\`);
            /** We destructured out the styles attribute as it's only for
       * custom elements declarative shadow dom  we create the style node
       * append the styles as the first child of the declarative shadowDom template */ if (styles) {
                templateChildren.push(serverTemplate('style', undefined, typeof styles === 'string' ? [
                    styles
                ] : [
                    ...styles
                ]));
            }
            /** We generally want to delegate focus to the first focusable element in
       * custom elements
       */ templateAttrs.push(\`shadowrootdelegatesfocus=\\"\${shadowRootDelegatesFocus}\\"\`);
        /** now that we've configured our declarative shadowDom
       * we append it to our root element.
       */ }
        const rootChildren = [];
        /** time to append the children to our template if we have em*/ const length = children.length;
        for(let i = 0; i < length; i++){
            const child = children[i];
            /** P1 Child is and string and custom element */ if (isCustomElement && typeof child === 'string') {
                templateChildren.push(trusted ? child : escape(child));
                continue;
            }
            /** P2 string not custom element */ if (typeof child === 'string') {
                rootChildren.push(trusted ? child : escape(child));
                continue;
            }
            /** P3 ServerElement and and the child is slotted */ if (isCustomElement && child.slot) {
                rootChildren.push(child());
                continue;
            }
            /** P4 ServerElement and custom element */ if (isCustomElement) {
                templateChildren.push(child());
                continue;
            }
            /**  P5 default use root tag*/ rootChildren.push(child());
        }
        const template = serverTemplate('template', templateAttrs, templateChildren);
        return serverTemplate(root, rootAttrs, [
            template,
            ...rootChildren
        ]);
    }><template></template></()=>{
        /** If the tag is script we must explicitly pass trusted */ if (tag === 'script' && !trusted) {
            throw new Error('Script tag not allowed unless \\\\'trusted\\\\' property set');
        }
        /** Now to determine what our root element is */ const root = typeof tag === 'string' ? tag.toLowerCase() : tag();
        const rootAttrs = [];
        /** if we have dataTrigger attribute wire up formatted correctly*/ dataTrigger && rootAttrs.push(\`\${_dataTrigger}=\\"\${Object.entries(dataTrigger).map(([ev, req])=>\`\${ev}->\${req}\`).join(' ')}\\"\`);
        /** if we have className add it to Element */ className && rootAttrs.push(\`class=\\"\${className}\\"\`);
        /** if we have htmlFor add it to Element */ htmlFor && rootAttrs.push(\`for=\\"\${htmlFor}\\"\`);
        /** if we have style add it to element */ style && rootAttrs.push(\`style=\\"\${Object.entries(style).map(([prop, val])=>\`\${prop}:\${val};\`).join(' ')}\\"\`);
        /** next we want to loops through our attributes */ for(const key in attributes){
            /** all events our delegated via the data-trigger attribute so we want
       * throw on attempts to provide \`on\` attributes
       */ if (key.startsWith('on')) {
                throw new Error('Attributes starting with \\\\'on\\\\' are not allowed.');
            }
            if (!primitives.has(trueTypeOf(attributes[key]))) {
                throw new Error(\`Attributes not declared in BaseProps must be of type Primitive: \${key} is not primitive\`);
            }
            /** grab the value from the attribute */ const value = attributes[key];
            /** convert camelCase attributes into dash-case ones */ const dashKey = key.replace(/[A-Z]/g, (m)=>\`-\${m.toLowerCase()}\`);
            /** test for and handle boolean attributes */ if (booleanAttrs.has(dashKey)) {
                rootAttrs.push(\`\${dashKey}\`);
                continue;
            }
            /** set the value so long as it's not nullish in we use the formatted value  */ const formattedValue = value ?? '';
            /** handle the rest of the attributes */ rootAttrs.push(\`\${dashKey}=\\"\${trusted ? \`\${formattedValue}\` : escape(\`\${formattedValue}\`)}\\"\`);
        }
        /** Our tag is a void tag so we can return it once we apply attributes */ if (typeof root === 'string' && voidTags.has(root)) {
            return \`<\${[
                root,
                ...rootAttrs
            ].join(' ')}/>\`;
        }
        /** Test if the the tag is a string and if it's a custom element */ const isCustomElement = customElementRegex.test(root);
        /** If our template is for a custom element we're going to create a
     * declarative shadow dom
     */ const templateAttrs = [];
        const templateChildren = [];
        if (isCustomElement) {
            /** Set the mode of the shadowDom */ templateAttrs.push(\`shadowrootmode=\\"\${shadowRootMode}\\"\`);
            /** We destructured out the styles attribute as it's only for
       * custom elements declarative shadow dom  we create the style node
       * append the styles as the first child of the declarative shadowDom template */ if (styles) {
                templateChildren.push(serverTemplate('style', undefined, typeof styles === 'string' ? [
                    styles
                ] : [
                    ...styles
                ]));
            }
            /** We generally want to delegate focus to the first focusable element in
       * custom elements
       */ templateAttrs.push(\`shadowrootdelegatesfocus=\\"\${shadowRootDelegatesFocus}\\"\`);
        /** now that we've configured our declarative shadowDom
       * we append it to our root element.
       */ }
        const rootChildren = [];
        /** time to append the children to our template if we have em*/ const length = children.length;
        for(let i = 0; i < length; i++){
            const child = children[i];
            /** P1 Child is and string and custom element */ if (isCustomElement && typeof child === 'string') {
                templateChildren.push(trusted ? child : escape(child));
                continue;
            }
            /** P2 string not custom element */ if (typeof child === 'string') {
                rootChildren.push(trusted ? child : escape(child));
                continue;
            }
            /** P3 ServerElement and and the child is slotted */ if (isCustomElement && child.slot) {
                rootChildren.push(child());
                continue;
            }
            /** P4 ServerElement and custom element */ if (isCustomElement) {
                templateChildren.push(child());
                continue;
            }
            /**  P5 default use root tag*/ rootChildren.push(child());
        }
        const template = serverTemplate('template', templateAttrs, templateChildren);
        return serverTemplate(root, rootAttrs, [
            template,
            ...rootChildren
        ]);
    }>"
`;

snapshot[`Island.template() 4`] = `
"<()=>{
        /** If the tag is script we must explicitly pass trusted */ if (tag === 'script' && !trusted) {
            throw new Error('Script tag not allowed unless \\\\'trusted\\\\' property set');
        }
        /** Now to determine what our root element is */ const root = typeof tag === 'string' ? tag.toLowerCase() : tag();
        const rootAttrs = [];
        /** if we have dataTrigger attribute wire up formatted correctly*/ dataTrigger && rootAttrs.push(\`\${_dataTrigger}=\\"\${Object.entries(dataTrigger).map(([ev, req])=>\`\${ev}->\${req}\`).join(' ')}\\"\`);
        /** if we have className add it to Element */ className && rootAttrs.push(\`class=\\"\${className}\\"\`);
        /** if we have htmlFor add it to Element */ htmlFor && rootAttrs.push(\`for=\\"\${htmlFor}\\"\`);
        /** if we have style add it to element */ style && rootAttrs.push(\`style=\\"\${Object.entries(style).map(([prop, val])=>\`\${prop}:\${val};\`).join(' ')}\\"\`);
        /** next we want to loops through our attributes */ for(const key in attributes){
            /** all events our delegated via the data-trigger attribute so we want
       * throw on attempts to provide \`on\` attributes
       */ if (key.startsWith('on')) {
                throw new Error('Attributes starting with \\\\'on\\\\' are not allowed.');
            }
            if (!primitives.has(trueTypeOf(attributes[key]))) {
                throw new Error(\`Attributes not declared in BaseProps must be of type Primitive: \${key} is not primitive\`);
            }
            /** grab the value from the attribute */ const value = attributes[key];
            /** convert camelCase attributes into dash-case ones */ const dashKey = key.replace(/[A-Z]/g, (m)=>\`-\${m.toLowerCase()}\`);
            /** test for and handle boolean attributes */ if (booleanAttrs.has(dashKey)) {
                rootAttrs.push(\`\${dashKey}\`);
                continue;
            }
            /** set the value so long as it's not nullish in we use the formatted value  */ const formattedValue = value ?? '';
            /** handle the rest of the attributes */ rootAttrs.push(\`\${dashKey}=\\"\${trusted ? \`\${formattedValue}\` : escape(\`\${formattedValue}\`)}\\"\`);
        }
        /** Our tag is a void tag so we can return it once we apply attributes */ if (typeof root === 'string' && voidTags.has(root)) {
            return \`<\${[
                root,
                ...rootAttrs
            ].join(' ')}/>\`;
        }
        /** Test if the the tag is a string and if it's a custom element */ const isCustomElement = customElementRegex.test(root);
        /** If our template is for a custom element we're going to create a
     * declarative shadow dom
     */ const templateAttrs = [];
        const templateChildren = [];
        if (isCustomElement) {
            /** Set the mode of the shadowDom */ templateAttrs.push(\`shadowrootmode=\\"\${shadowRootMode}\\"\`);
            /** We destructured out the styles attribute as it's only for
       * custom elements declarative shadow dom  we create the style node
       * append the styles as the first child of the declarative shadowDom template */ if (styles) {
                templateChildren.push(serverTemplate('style', undefined, typeof styles === 'string' ? [
                    styles
                ] : [
                    ...styles
                ]));
            }
            /** We generally want to delegate focus to the first focusable element in
       * custom elements
       */ templateAttrs.push(\`shadowrootdelegatesfocus=\\"\${shadowRootDelegatesFocus}\\"\`);
        /** now that we've configured our declarative shadowDom
       * we append it to our root element.
       */ }
        const rootChildren = [];
        /** time to append the children to our template if we have em*/ const length = children.length;
        for(let i = 0; i < length; i++){
            const child = children[i];
            /** P1 Child is and string and custom element */ if (isCustomElement && typeof child === 'string') {
                templateChildren.push(trusted ? child : escape(child));
                continue;
            }
            /** P2 string not custom element */ if (typeof child === 'string') {
                rootChildren.push(trusted ? child : escape(child));
                continue;
            }
            /** P3 ServerElement and and the child is slotted */ if (isCustomElement && child.slot) {
                rootChildren.push(child());
                continue;
            }
            /** P4 ServerElement and custom element */ if (isCustomElement) {
                templateChildren.push(child());
                continue;
            }
            /**  P5 default use root tag*/ rootChildren.push(child());
        }
        const template = serverTemplate('template', templateAttrs, templateChildren);
        return serverTemplate(root, rootAttrs, [
            template,
            ...rootChildren
        ]);
    }><template></template></()=>{
        /** If the tag is script we must explicitly pass trusted */ if (tag === 'script' && !trusted) {
            throw new Error('Script tag not allowed unless \\\\'trusted\\\\' property set');
        }
        /** Now to determine what our root element is */ const root = typeof tag === 'string' ? tag.toLowerCase() : tag();
        const rootAttrs = [];
        /** if we have dataTrigger attribute wire up formatted correctly*/ dataTrigger && rootAttrs.push(\`\${_dataTrigger}=\\"\${Object.entries(dataTrigger).map(([ev, req])=>\`\${ev}->\${req}\`).join(' ')}\\"\`);
        /** if we have className add it to Element */ className && rootAttrs.push(\`class=\\"\${className}\\"\`);
        /** if we have htmlFor add it to Element */ htmlFor && rootAttrs.push(\`for=\\"\${htmlFor}\\"\`);
        /** if we have style add it to element */ style && rootAttrs.push(\`style=\\"\${Object.entries(style).map(([prop, val])=>\`\${prop}:\${val};\`).join(' ')}\\"\`);
        /** next we want to loops through our attributes */ for(const key in attributes){
            /** all events our delegated via the data-trigger attribute so we want
       * throw on attempts to provide \`on\` attributes
       */ if (key.startsWith('on')) {
                throw new Error('Attributes starting with \\\\'on\\\\' are not allowed.');
            }
            if (!primitives.has(trueTypeOf(attributes[key]))) {
                throw new Error(\`Attributes not declared in BaseProps must be of type Primitive: \${key} is not primitive\`);
            }
            /** grab the value from the attribute */ const value = attributes[key];
            /** convert camelCase attributes into dash-case ones */ const dashKey = key.replace(/[A-Z]/g, (m)=>\`-\${m.toLowerCase()}\`);
            /** test for and handle boolean attributes */ if (booleanAttrs.has(dashKey)) {
                rootAttrs.push(\`\${dashKey}\`);
                continue;
            }
            /** set the value so long as it's not nullish in we use the formatted value  */ const formattedValue = value ?? '';
            /** handle the rest of the attributes */ rootAttrs.push(\`\${dashKey}=\\"\${trusted ? \`\${formattedValue}\` : escape(\`\${formattedValue}\`)}\\"\`);
        }
        /** Our tag is a void tag so we can return it once we apply attributes */ if (typeof root === 'string' && voidTags.has(root)) {
            return \`<\${[
                root,
                ...rootAttrs
            ].join(' ')}/>\`;
        }
        /** Test if the the tag is a string and if it's a custom element */ const isCustomElement = customElementRegex.test(root);
        /** If our template is for a custom element we're going to create a
     * declarative shadow dom
     */ const templateAttrs = [];
        const templateChildren = [];
        if (isCustomElement) {
            /** Set the mode of the shadowDom */ templateAttrs.push(\`shadowrootmode=\\"\${shadowRootMode}\\"\`);
            /** We destructured out the styles attribute as it's only for
       * custom elements declarative shadow dom  we create the style node
       * append the styles as the first child of the declarative shadowDom template */ if (styles) {
                templateChildren.push(serverTemplate('style', undefined, typeof styles === 'string' ? [
                    styles
                ] : [
                    ...styles
                ]));
            }
            /** We generally want to delegate focus to the first focusable element in
       * custom elements
       */ templateAttrs.push(\`shadowrootdelegatesfocus=\\"\${shadowRootDelegatesFocus}\\"\`);
        /** now that we've configured our declarative shadowDom
       * we append it to our root element.
       */ }
        const rootChildren = [];
        /** time to append the children to our template if we have em*/ const length = children.length;
        for(let i = 0; i < length; i++){
            const child = children[i];
            /** P1 Child is and string and custom element */ if (isCustomElement && typeof child === 'string') {
                templateChildren.push(trusted ? child : escape(child));
                continue;
            }
            /** P2 string not custom element */ if (typeof child === 'string') {
                rootChildren.push(trusted ? child : escape(child));
                continue;
            }
            /** P3 ServerElement and and the child is slotted */ if (isCustomElement && child.slot) {
                rootChildren.push(child());
                continue;
            }
            /** P4 ServerElement and custom element */ if (isCustomElement) {
                templateChildren.push(child());
                continue;
            }
            /**  P5 default use root tag*/ rootChildren.push(child());
        }
        const template = serverTemplate('template', templateAttrs, templateChildren);
        return serverTemplate(root, rootAttrs, [
            template,
            ...rootChildren
        ]);
    }>"
`;

snapshot[`Island.template() 5`] = `
"<()=>{
        /** If the tag is script we must explicitly pass trusted */ if (tag === 'script' && !trusted) {
            throw new Error('Script tag not allowed unless \\\\'trusted\\\\' property set');
        }
        /** Now to determine what our root element is */ const root = typeof tag === 'string' ? tag.toLowerCase() : tag();
        const rootAttrs = [];
        /** if we have dataTrigger attribute wire up formatted correctly*/ dataTrigger && rootAttrs.push(\`\${_dataTrigger}=\\"\${Object.entries(dataTrigger).map(([ev, req])=>\`\${ev}->\${req}\`).join(' ')}\\"\`);
        /** if we have className add it to Element */ className && rootAttrs.push(\`class=\\"\${className}\\"\`);
        /** if we have htmlFor add it to Element */ htmlFor && rootAttrs.push(\`for=\\"\${htmlFor}\\"\`);
        /** if we have style add it to element */ style && rootAttrs.push(\`style=\\"\${Object.entries(style).map(([prop, val])=>\`\${prop}:\${val};\`).join(' ')}\\"\`);
        /** next we want to loops through our attributes */ for(const key in attributes){
            /** all events our delegated via the data-trigger attribute so we want
       * throw on attempts to provide \`on\` attributes
       */ if (key.startsWith('on')) {
                throw new Error('Attributes starting with \\\\'on\\\\' are not allowed.');
            }
            if (!primitives.has(trueTypeOf(attributes[key]))) {
                throw new Error(\`Attributes not declared in BaseProps must be of type Primitive: \${key} is not primitive\`);
            }
            /** grab the value from the attribute */ const value = attributes[key];
            /** convert camelCase attributes into dash-case ones */ const dashKey = key.replace(/[A-Z]/g, (m)=>\`-\${m.toLowerCase()}\`);
            /** test for and handle boolean attributes */ if (booleanAttrs.has(dashKey)) {
                rootAttrs.push(\`\${dashKey}\`);
                continue;
            }
            /** set the value so long as it's not nullish in we use the formatted value  */ const formattedValue = value ?? '';
            /** handle the rest of the attributes */ rootAttrs.push(\`\${dashKey}=\\"\${trusted ? \`\${formattedValue}\` : escape(\`\${formattedValue}\`)}\\"\`);
        }
        /** Our tag is a void tag so we can return it once we apply attributes */ if (typeof root === 'string' && voidTags.has(root)) {
            return \`<\${[
                root,
                ...rootAttrs
            ].join(' ')}/>\`;
        }
        /** Test if the the tag is a string and if it's a custom element */ const isCustomElement = customElementRegex.test(root);
        /** If our template is for a custom element we're going to create a
     * declarative shadow dom
     */ const templateAttrs = [];
        const templateChildren = [];
        if (isCustomElement) {
            /** Set the mode of the shadowDom */ templateAttrs.push(\`shadowrootmode=\\"\${shadowRootMode}\\"\`);
            /** We destructured out the styles attribute as it's only for
       * custom elements declarative shadow dom  we create the style node
       * append the styles as the first child of the declarative shadowDom template */ if (styles) {
                templateChildren.push(serverTemplate('style', undefined, typeof styles === 'string' ? [
                    styles
                ] : [
                    ...styles
                ]));
            }
            /** We generally want to delegate focus to the first focusable element in
       * custom elements
       */ templateAttrs.push(\`shadowrootdelegatesfocus=\\"\${shadowRootDelegatesFocus}\\"\`);
        /** now that we've configured our declarative shadowDom
       * we append it to our root element.
       */ }
        const rootChildren = [];
        /** time to append the children to our template if we have em*/ const length = children.length;
        for(let i = 0; i < length; i++){
            const child = children[i];
            /** P1 Child is and string and custom element */ if (isCustomElement && typeof child === 'string') {
                templateChildren.push(trusted ? child : escape(child));
                continue;
            }
            /** P2 string not custom element */ if (typeof child === 'string') {
                rootChildren.push(trusted ? child : escape(child));
                continue;
            }
            /** P3 ServerElement and and the child is slotted */ if (isCustomElement && child.slot) {
                rootChildren.push(child());
                continue;
            }
            /** P4 ServerElement and custom element */ if (isCustomElement) {
                templateChildren.push(child());
                continue;
            }
            /**  P5 default use root tag*/ rootChildren.push(child());
        }
        const template = serverTemplate('template', templateAttrs, templateChildren);
        return serverTemplate(root, rootAttrs, [
            template,
            ...rootChildren
        ]);
    }><template></template> <div><template></template> <h1><template></template> h e a d e r</h1> <slot name=\\"slot\\"><template></template></slot></div> <div slot=\\"slot\\"><template></template> s l o t t e d</div></()=>{
        /** If the tag is script we must explicitly pass trusted */ if (tag === 'script' && !trusted) {
            throw new Error('Script tag not allowed unless \\\\'trusted\\\\' property set');
        }
        /** Now to determine what our root element is */ const root = typeof tag === 'string' ? tag.toLowerCase() : tag();
        const rootAttrs = [];
        /** if we have dataTrigger attribute wire up formatted correctly*/ dataTrigger && rootAttrs.push(\`\${_dataTrigger}=\\"\${Object.entries(dataTrigger).map(([ev, req])=>\`\${ev}->\${req}\`).join(' ')}\\"\`);
        /** if we have className add it to Element */ className && rootAttrs.push(\`class=\\"\${className}\\"\`);
        /** if we have htmlFor add it to Element */ htmlFor && rootAttrs.push(\`for=\\"\${htmlFor}\\"\`);
        /** if we have style add it to element */ style && rootAttrs.push(\`style=\\"\${Object.entries(style).map(([prop, val])=>\`\${prop}:\${val};\`).join(' ')}\\"\`);
        /** next we want to loops through our attributes */ for(const key in attributes){
            /** all events our delegated via the data-trigger attribute so we want
       * throw on attempts to provide \`on\` attributes
       */ if (key.startsWith('on')) {
                throw new Error('Attributes starting with \\\\'on\\\\' are not allowed.');
            }
            if (!primitives.has(trueTypeOf(attributes[key]))) {
                throw new Error(\`Attributes not declared in BaseProps must be of type Primitive: \${key} is not primitive\`);
            }
            /** grab the value from the attribute */ const value = attributes[key];
            /** convert camelCase attributes into dash-case ones */ const dashKey = key.replace(/[A-Z]/g, (m)=>\`-\${m.toLowerCase()}\`);
            /** test for and handle boolean attributes */ if (booleanAttrs.has(dashKey)) {
                rootAttrs.push(\`\${dashKey}\`);
                continue;
            }
            /** set the value so long as it's not nullish in we use the formatted value  */ const formattedValue = value ?? '';
            /** handle the rest of the attributes */ rootAttrs.push(\`\${dashKey}=\\"\${trusted ? \`\${formattedValue}\` : escape(\`\${formattedValue}\`)}\\"\`);
        }
        /** Our tag is a void tag so we can return it once we apply attributes */ if (typeof root === 'string' && voidTags.has(root)) {
            return \`<\${[
                root,
                ...rootAttrs
            ].join(' ')}/>\`;
        }
        /** Test if the the tag is a string and if it's a custom element */ const isCustomElement = customElementRegex.test(root);
        /** If our template is for a custom element we're going to create a
     * declarative shadow dom
     */ const templateAttrs = [];
        const templateChildren = [];
        if (isCustomElement) {
            /** Set the mode of the shadowDom */ templateAttrs.push(\`shadowrootmode=\\"\${shadowRootMode}\\"\`);
            /** We destructured out the styles attribute as it's only for
       * custom elements declarative shadow dom  we create the style node
       * append the styles as the first child of the declarative shadowDom template */ if (styles) {
                templateChildren.push(serverTemplate('style', undefined, typeof styles === 'string' ? [
                    styles
                ] : [
                    ...styles
                ]));
            }
            /** We generally want to delegate focus to the first focusable element in
       * custom elements
       */ templateAttrs.push(\`shadowrootdelegatesfocus=\\"\${shadowRootDelegatesFocus}\\"\`);
        /** now that we've configured our declarative shadowDom
       * we append it to our root element.
       */ }
        const rootChildren = [];
        /** time to append the children to our template if we have em*/ const length = children.length;
        for(let i = 0; i < length; i++){
            const child = children[i];
            /** P1 Child is and string and custom element */ if (isCustomElement && typeof child === 'string') {
                templateChildren.push(trusted ? child : escape(child));
                continue;
            }
            /** P2 string not custom element */ if (typeof child === 'string') {
                rootChildren.push(trusted ? child : escape(child));
                continue;
            }
            /** P3 ServerElement and and the child is slotted */ if (isCustomElement && child.slot) {
                rootChildren.push(child());
                continue;
            }
            /** P4 ServerElement and custom element */ if (isCustomElement) {
                templateChildren.push(child());
                continue;
            }
            /**  P5 default use root tag*/ rootChildren.push(child());
        }
        const template = serverTemplate('template', templateAttrs, templateChildren);
        return serverTemplate(root, rootAttrs, [
            template,
            ...rootChildren
        ]);
    }>"
`;

snapshot[`Island.template() 6`] = `
"<()=>{
        /** If the tag is script we must explicitly pass trusted */ if (tag === 'script' && !trusted) {
            throw new Error('Script tag not allowed unless \\\\'trusted\\\\' property set');
        }
        /** Now to determine what our root element is */ const root = typeof tag === 'string' ? tag.toLowerCase() : tag();
        const rootAttrs = [];
        /** if we have dataTrigger attribute wire up formatted correctly*/ dataTrigger && rootAttrs.push(\`\${_dataTrigger}=\\"\${Object.entries(dataTrigger).map(([ev, req])=>\`\${ev}->\${req}\`).join(' ')}\\"\`);
        /** if we have className add it to Element */ className && rootAttrs.push(\`class=\\"\${className}\\"\`);
        /** if we have htmlFor add it to Element */ htmlFor && rootAttrs.push(\`for=\\"\${htmlFor}\\"\`);
        /** if we have style add it to element */ style && rootAttrs.push(\`style=\\"\${Object.entries(style).map(([prop, val])=>\`\${prop}:\${val};\`).join(' ')}\\"\`);
        /** next we want to loops through our attributes */ for(const key in attributes){
            /** all events our delegated via the data-trigger attribute so we want
       * throw on attempts to provide \`on\` attributes
       */ if (key.startsWith('on')) {
                throw new Error('Attributes starting with \\\\'on\\\\' are not allowed.');
            }
            if (!primitives.has(trueTypeOf(attributes[key]))) {
                throw new Error(\`Attributes not declared in BaseProps must be of type Primitive: \${key} is not primitive\`);
            }
            /** grab the value from the attribute */ const value = attributes[key];
            /** convert camelCase attributes into dash-case ones */ const dashKey = key.replace(/[A-Z]/g, (m)=>\`-\${m.toLowerCase()}\`);
            /** test for and handle boolean attributes */ if (booleanAttrs.has(dashKey)) {
                rootAttrs.push(\`\${dashKey}\`);
                continue;
            }
            /** set the value so long as it's not nullish in we use the formatted value  */ const formattedValue = value ?? '';
            /** handle the rest of the attributes */ rootAttrs.push(\`\${dashKey}=\\"\${trusted ? \`\${formattedValue}\` : escape(\`\${formattedValue}\`)}\\"\`);
        }
        /** Our tag is a void tag so we can return it once we apply attributes */ if (typeof root === 'string' && voidTags.has(root)) {
            return \`<\${[
                root,
                ...rootAttrs
            ].join(' ')}/>\`;
        }
        /** Test if the the tag is a string and if it's a custom element */ const isCustomElement = customElementRegex.test(root);
        /** If our template is for a custom element we're going to create a
     * declarative shadow dom
     */ const templateAttrs = [];
        const templateChildren = [];
        if (isCustomElement) {
            /** Set the mode of the shadowDom */ templateAttrs.push(\`shadowrootmode=\\"\${shadowRootMode}\\"\`);
            /** We destructured out the styles attribute as it's only for
       * custom elements declarative shadow dom  we create the style node
       * append the styles as the first child of the declarative shadowDom template */ if (styles) {
                templateChildren.push(serverTemplate('style', undefined, typeof styles === 'string' ? [
                    styles
                ] : [
                    ...styles
                ]));
            }
            /** We generally want to delegate focus to the first focusable element in
       * custom elements
       */ templateAttrs.push(\`shadowrootdelegatesfocus=\\"\${shadowRootDelegatesFocus}\\"\`);
        /** now that we've configured our declarative shadowDom
       * we append it to our root element.
       */ }
        const rootChildren = [];
        /** time to append the children to our template if we have em*/ const length = children.length;
        for(let i = 0; i < length; i++){
            const child = children[i];
            /** P1 Child is and string and custom element */ if (isCustomElement && typeof child === 'string') {
                templateChildren.push(trusted ? child : escape(child));
                continue;
            }
            /** P2 string not custom element */ if (typeof child === 'string') {
                rootChildren.push(trusted ? child : escape(child));
                continue;
            }
            /** P3 ServerElement and and the child is slotted */ if (isCustomElement && child.slot) {
                rootChildren.push(child());
                continue;
            }
            /** P4 ServerElement and custom element */ if (isCustomElement) {
                templateChildren.push(child());
                continue;
            }
            /**  P5 default use root tag*/ rootChildren.push(child());
        }
        const template = serverTemplate('template', templateAttrs, templateChildren);
        return serverTemplate(root, rootAttrs, [
            template,
            ...rootChildren
        ]);
    }><template></template></()=>{
        /** If the tag is script we must explicitly pass trusted */ if (tag === 'script' && !trusted) {
            throw new Error('Script tag not allowed unless \\\\'trusted\\\\' property set');
        }
        /** Now to determine what our root element is */ const root = typeof tag === 'string' ? tag.toLowerCase() : tag();
        const rootAttrs = [];
        /** if we have dataTrigger attribute wire up formatted correctly*/ dataTrigger && rootAttrs.push(\`\${_dataTrigger}=\\"\${Object.entries(dataTrigger).map(([ev, req])=>\`\${ev}->\${req}\`).join(' ')}\\"\`);
        /** if we have className add it to Element */ className && rootAttrs.push(\`class=\\"\${className}\\"\`);
        /** if we have htmlFor add it to Element */ htmlFor && rootAttrs.push(\`for=\\"\${htmlFor}\\"\`);
        /** if we have style add it to element */ style && rootAttrs.push(\`style=\\"\${Object.entries(style).map(([prop, val])=>\`\${prop}:\${val};\`).join(' ')}\\"\`);
        /** next we want to loops through our attributes */ for(const key in attributes){
            /** all events our delegated via the data-trigger attribute so we want
       * throw on attempts to provide \`on\` attributes
       */ if (key.startsWith('on')) {
                throw new Error('Attributes starting with \\\\'on\\\\' are not allowed.');
            }
            if (!primitives.has(trueTypeOf(attributes[key]))) {
                throw new Error(\`Attributes not declared in BaseProps must be of type Primitive: \${key} is not primitive\`);
            }
            /** grab the value from the attribute */ const value = attributes[key];
            /** convert camelCase attributes into dash-case ones */ const dashKey = key.replace(/[A-Z]/g, (m)=>\`-\${m.toLowerCase()}\`);
            /** test for and handle boolean attributes */ if (booleanAttrs.has(dashKey)) {
                rootAttrs.push(\`\${dashKey}\`);
                continue;
            }
            /** set the value so long as it's not nullish in we use the formatted value  */ const formattedValue = value ?? '';
            /** handle the rest of the attributes */ rootAttrs.push(\`\${dashKey}=\\"\${trusted ? \`\${formattedValue}\` : escape(\`\${formattedValue}\`)}\\"\`);
        }
        /** Our tag is a void tag so we can return it once we apply attributes */ if (typeof root === 'string' && voidTags.has(root)) {
            return \`<\${[
                root,
                ...rootAttrs
            ].join(' ')}/>\`;
        }
        /** Test if the the tag is a string and if it's a custom element */ const isCustomElement = customElementRegex.test(root);
        /** If our template is for a custom element we're going to create a
     * declarative shadow dom
     */ const templateAttrs = [];
        const templateChildren = [];
        if (isCustomElement) {
            /** Set the mode of the shadowDom */ templateAttrs.push(\`shadowrootmode=\\"\${shadowRootMode}\\"\`);
            /** We destructured out the styles attribute as it's only for
       * custom elements declarative shadow dom  we create the style node
       * append the styles as the first child of the declarative shadowDom template */ if (styles) {
                templateChildren.push(serverTemplate('style', undefined, typeof styles === 'string' ? [
                    styles
                ] : [
                    ...styles
                ]));
            }
            /** We generally want to delegate focus to the first focusable element in
       * custom elements
       */ templateAttrs.push(\`shadowrootdelegatesfocus=\\"\${shadowRootDelegatesFocus}\\"\`);
        /** now that we've configured our declarative shadowDom
       * we append it to our root element.
       */ }
        const rootChildren = [];
        /** time to append the children to our template if we have em*/ const length = children.length;
        for(let i = 0; i < length; i++){
            const child = children[i];
            /** P1 Child is and string and custom element */ if (isCustomElement && typeof child === 'string') {
                templateChildren.push(trusted ? child : escape(child));
                continue;
            }
            /** P2 string not custom element */ if (typeof child === 'string') {
                rootChildren.push(trusted ? child : escape(child));
                continue;
            }
            /** P3 ServerElement and and the child is slotted */ if (isCustomElement && child.slot) {
                rootChildren.push(child());
                continue;
            }
            /** P4 ServerElement and custom element */ if (isCustomElement) {
                templateChildren.push(child());
                continue;
            }
            /**  P5 default use root tag*/ rootChildren.push(child());
        }
        const template = serverTemplate('template', templateAttrs, templateChildren);
        return serverTemplate(root, rootAttrs, [
            template,
            ...rootChildren
        ]);
    }>"
`;

snapshot[`Island.template() 7`] = `
"<()=>{
        /** If the tag is script we must explicitly pass trusted */ if (tag === 'script' && !trusted) {
            throw new Error('Script tag not allowed unless \\\\'trusted\\\\' property set');
        }
        /** Now to determine what our root element is */ const root = typeof tag === 'string' ? tag.toLowerCase() : tag();
        const rootAttrs = [];
        /** if we have dataTrigger attribute wire up formatted correctly*/ dataTrigger && rootAttrs.push(\`\${_dataTrigger}=\\"\${Object.entries(dataTrigger).map(([ev, req])=>\`\${ev}->\${req}\`).join(' ')}\\"\`);
        /** if we have className add it to Element */ className && rootAttrs.push(\`class=\\"\${className}\\"\`);
        /** if we have htmlFor add it to Element */ htmlFor && rootAttrs.push(\`for=\\"\${htmlFor}\\"\`);
        /** if we have style add it to element */ style && rootAttrs.push(\`style=\\"\${Object.entries(style).map(([prop, val])=>\`\${prop}:\${val};\`).join(' ')}\\"\`);
        /** next we want to loops through our attributes */ for(const key in attributes){
            /** all events our delegated via the data-trigger attribute so we want
       * throw on attempts to provide \`on\` attributes
       */ if (key.startsWith('on')) {
                throw new Error('Attributes starting with \\\\'on\\\\' are not allowed.');
            }
            if (!primitives.has(trueTypeOf(attributes[key]))) {
                throw new Error(\`Attributes not declared in BaseProps must be of type Primitive: \${key} is not primitive\`);
            }
            /** grab the value from the attribute */ const value = attributes[key];
            /** convert camelCase attributes into dash-case ones */ const dashKey = key.replace(/[A-Z]/g, (m)=>\`-\${m.toLowerCase()}\`);
            /** test for and handle boolean attributes */ if (booleanAttrs.has(dashKey)) {
                rootAttrs.push(\`\${dashKey}\`);
                continue;
            }
            /** set the value so long as it's not nullish in we use the formatted value  */ const formattedValue = value ?? '';
            /** handle the rest of the attributes */ rootAttrs.push(\`\${dashKey}=\\"\${trusted ? \`\${formattedValue}\` : escape(\`\${formattedValue}\`)}\\"\`);
        }
        /** Our tag is a void tag so we can return it once we apply attributes */ if (typeof root === 'string' && voidTags.has(root)) {
            return \`<\${[
                root,
                ...rootAttrs
            ].join(' ')}/>\`;
        }
        /** Test if the the tag is a string and if it's a custom element */ const isCustomElement = customElementRegex.test(root);
        /** If our template is for a custom element we're going to create a
     * declarative shadow dom
     */ const templateAttrs = [];
        const templateChildren = [];
        if (isCustomElement) {
            /** Set the mode of the shadowDom */ templateAttrs.push(\`shadowrootmode=\\"\${shadowRootMode}\\"\`);
            /** We destructured out the styles attribute as it's only for
       * custom elements declarative shadow dom  we create the style node
       * append the styles as the first child of the declarative shadowDom template */ if (styles) {
                templateChildren.push(serverTemplate('style', undefined, typeof styles === 'string' ? [
                    styles
                ] : [
                    ...styles
                ]));
            }
            /** We generally want to delegate focus to the first focusable element in
       * custom elements
       */ templateAttrs.push(\`shadowrootdelegatesfocus=\\"\${shadowRootDelegatesFocus}\\"\`);
        /** now that we've configured our declarative shadowDom
       * we append it to our root element.
       */ }
        const rootChildren = [];
        /** time to append the children to our template if we have em*/ const length = children.length;
        for(let i = 0; i < length; i++){
            const child = children[i];
            /** P1 Child is and string and custom element */ if (isCustomElement && typeof child === 'string') {
                templateChildren.push(trusted ? child : escape(child));
                continue;
            }
            /** P2 string not custom element */ if (typeof child === 'string') {
                rootChildren.push(trusted ? child : escape(child));
                continue;
            }
            /** P3 ServerElement and and the child is slotted */ if (isCustomElement && child.slot) {
                rootChildren.push(child());
                continue;
            }
            /** P4 ServerElement and custom element */ if (isCustomElement) {
                templateChildren.push(child());
                continue;
            }
            /**  P5 default use root tag*/ rootChildren.push(child());
        }
        const template = serverTemplate('template', templateAttrs, templateChildren);
        return serverTemplate(root, rootAttrs, [
            template,
            ...rootChildren
        ]);
    }><template></template></()=>{
        /** If the tag is script we must explicitly pass trusted */ if (tag === 'script' && !trusted) {
            throw new Error('Script tag not allowed unless \\\\'trusted\\\\' property set');
        }
        /** Now to determine what our root element is */ const root = typeof tag === 'string' ? tag.toLowerCase() : tag();
        const rootAttrs = [];
        /** if we have dataTrigger attribute wire up formatted correctly*/ dataTrigger && rootAttrs.push(\`\${_dataTrigger}=\\"\${Object.entries(dataTrigger).map(([ev, req])=>\`\${ev}->\${req}\`).join(' ')}\\"\`);
        /** if we have className add it to Element */ className && rootAttrs.push(\`class=\\"\${className}\\"\`);
        /** if we have htmlFor add it to Element */ htmlFor && rootAttrs.push(\`for=\\"\${htmlFor}\\"\`);
        /** if we have style add it to element */ style && rootAttrs.push(\`style=\\"\${Object.entries(style).map(([prop, val])=>\`\${prop}:\${val};\`).join(' ')}\\"\`);
        /** next we want to loops through our attributes */ for(const key in attributes){
            /** all events our delegated via the data-trigger attribute so we want
       * throw on attempts to provide \`on\` attributes
       */ if (key.startsWith('on')) {
                throw new Error('Attributes starting with \\\\'on\\\\' are not allowed.');
            }
            if (!primitives.has(trueTypeOf(attributes[key]))) {
                throw new Error(\`Attributes not declared in BaseProps must be of type Primitive: \${key} is not primitive\`);
            }
            /** grab the value from the attribute */ const value = attributes[key];
            /** convert camelCase attributes into dash-case ones */ const dashKey = key.replace(/[A-Z]/g, (m)=>\`-\${m.toLowerCase()}\`);
            /** test for and handle boolean attributes */ if (booleanAttrs.has(dashKey)) {
                rootAttrs.push(\`\${dashKey}\`);
                continue;
            }
            /** set the value so long as it's not nullish in we use the formatted value  */ const formattedValue = value ?? '';
            /** handle the rest of the attributes */ rootAttrs.push(\`\${dashKey}=\\"\${trusted ? \`\${formattedValue}\` : escape(\`\${formattedValue}\`)}\\"\`);
        }
        /** Our tag is a void tag so we can return it once we apply attributes */ if (typeof root === 'string' && voidTags.has(root)) {
            return \`<\${[
                root,
                ...rootAttrs
            ].join(' ')}/>\`;
        }
        /** Test if the the tag is a string and if it's a custom element */ const isCustomElement = customElementRegex.test(root);
        /** If our template is for a custom element we're going to create a
     * declarative shadow dom
     */ const templateAttrs = [];
        const templateChildren = [];
        if (isCustomElement) {
            /** Set the mode of the shadowDom */ templateAttrs.push(\`shadowrootmode=\\"\${shadowRootMode}\\"\`);
            /** We destructured out the styles attribute as it's only for
       * custom elements declarative shadow dom  we create the style node
       * append the styles as the first child of the declarative shadowDom template */ if (styles) {
                templateChildren.push(serverTemplate('style', undefined, typeof styles === 'string' ? [
                    styles
                ] : [
                    ...styles
                ]));
            }
            /** We generally want to delegate focus to the first focusable element in
       * custom elements
       */ templateAttrs.push(\`shadowrootdelegatesfocus=\\"\${shadowRootDelegatesFocus}\\"\`);
        /** now that we've configured our declarative shadowDom
       * we append it to our root element.
       */ }
        const rootChildren = [];
        /** time to append the children to our template if we have em*/ const length = children.length;
        for(let i = 0; i < length; i++){
            const child = children[i];
            /** P1 Child is and string and custom element */ if (isCustomElement && typeof child === 'string') {
                templateChildren.push(trusted ? child : escape(child));
                continue;
            }
            /** P2 string not custom element */ if (typeof child === 'string') {
                rootChildren.push(trusted ? child : escape(child));
                continue;
            }
            /** P3 ServerElement and and the child is slotted */ if (isCustomElement && child.slot) {
                rootChildren.push(child());
                continue;
            }
            /** P4 ServerElement and custom element */ if (isCustomElement) {
                templateChildren.push(child());
                continue;
            }
            /**  P5 default use root tag*/ rootChildren.push(child());
        }
        const template = serverTemplate('template', templateAttrs, templateChildren);
        return serverTemplate(root, rootAttrs, [
            template,
            ...rootChildren
        ]);
    }>"
`;
